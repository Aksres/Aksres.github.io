[{"title":"将你的 Sublime Text 3 打造成完美的 c++ 编辑器","date":"2021-02-25T19:12:22.000Z","path":"2021/02/26/将你的 Sublime Text 3 打造成完美的 c++ 编辑器/","text":"Part -1 Update Update1 2021-2-28 更新图片 Part 0 前言 因为 hexo 渲染的原因，下面一些 Markdown 的锅作者到现在都不会修，所以建议大家到 这里 查看。 搭建需要的东西都在 这个链接 中。 提取码：7sap Sublime Text 3 是一种实用性较强的编辑工具。 没错就这么多 诶不是还能说什么 Part 1 下载配置 Sublime Text 3 下载 官网 当然也可以用我的安装包下载。版本号为 321132113211。 下载完成后，打开 Sublime ，你会看到这样一个界面。 如果没有找到， 就 Win + R ，输入 Sublime 回车。 （最右下角有个框，是代码语言选择区） 先别急着操作，在你的 Sublime 下载目录下新建一个叫 Data 的文件夹，重启 Sublime ，然后你的数据就会被保存到 Data 里。 激活 Sublime 如果看到左上方显示 UNREGISTERED ，就是说你的 Sublime 没有激活。 先查看版本号， 点击 Help &gt; About Sublime Text ，找到 Build 后面的数字，然后百度一下激活码。将激活码粘贴到 Help &gt; Enter Lisence 。 下面是 321132113211 的激活码 12345678910111213----- BEGIN LICENSE -----Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864------ END LICENSE ------ 配置 Package Control 阅读以下步骤前，请确保 Sublime 已经激活！ Package Control 是 Sublime 的插件管理器，必须要安装 Package Control 才能下载和使用插件。 安装 Package Control 有两种办法。第一种办法是 Ctrl + ` 打开以下界面。在红色标记的地方输入以下代码： 1import urllib.request,os,hashlib; h &#x3D; &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by &#x3D; urllib.request.urlopen( &#39;http:&#x2F;&#x2F;packagecontrol.io&#x2F;&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh &#x3D; hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh !&#x3D; h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by) 但是，如果你不会珂学上网或者翻墙，这种方法很可能不行，这时候就要采用第二种方法。 在 Sublime 的安装目录下打开 Data &gt; Installed Packages ，将材料里的 Package Control.sublime-package 复制到这个文件夹里。重启 Sublime 。如果看到 Preferences 里出现了红色圈圈里的两个东西，就说明安装成功了。 配置 channel 千万不要下载完 Package Control 就不看这一步啊，报错了别来找我啊 材料里有一个 channel_v3.json ，把它放到 Sublime 的下载文件夹里。 打开 Preferences &gt; Package Settings &gt; Package Control &gt; Setting - User ，在 &quot;bootstrapped&quot;: true, 后面粘贴以下内容（那个路径就是你放这个文件的路径） 1234&quot;channels&quot;:[ &quot;D:/Sublime Text 3/channel_v3.json&quot; ], 然后就可以了。 安装插件和主题 Sublime 本身提供了几种主题和配色方案，可以在这里寻找。 安装插件同样有两种办法，一种是 Ctrl + Shift + P 打开并找到 Install Package ，然后输入插件名下载。 如果下载几十分钟都没出来，说明插件被墙了，这时候就需要百度，从插件官网 Github 上把插件包搞下来，解压后放到 Data &gt; Packages 里。然后就能使用了。 这里推荐一个主题 ： Ayu 这个主题有三种，Dark , Light 和 mirage 。 食用效果 ： （建议不要使用 Ayu 的配色方案，眼睛可能会没） 再推荐两个配色方案， One Dark 和 Solarized Light 。 食用效果 ： One Dark : Solarized Light： 如果需要汉化，可以在 Install package 里搜索 ChineseLocalizations 并下载，这个插件不会被墙掉。然后在 Help &gt; Languages 中更改语言。 卸载插件 + Shift + P ``` 并找到 ```Remove Packages``` 选择要删除的插件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071**推荐几个好用的插件**- &#96;&#96;&#96;Convert to UTF8 &#96;&#96;&#96; 解决中文乱码 [项目地址](https:&#x2F;&#x2F;github.com&#x2F;seanliang&#x2F;ConvertToUTF8)- &#96;&#96;&#96;Git&#96;&#96;&#96; 将你的 Sublime 变成 Git 编辑器，基本上涵盖了 Git 软件的内容 （可以用 &#96;&#96;&#96;Package Control&#96;&#96;&#96; 下载）- &#96;&#96;&#96;SublimeREPL&#96;&#96;&#96; 实现程序交互，可以让 Python ， F# ，PHP ， Ruby ， Lua 等一堆语言可以输入。- &#96;&#96;&#96;Less&#96;&#96;&#96; 支持 Less 程序高亮。- &#96;&#96;&#96;Emmet&#96;&#96;&#96; 编写快捷键。 [官网](https:&#x2F;&#x2F;docs.emmet.io&#x2F;)- &#96;&#96;&#96;JSformet&#96;&#96;&#96; 格式化 Javascript 代码[项目地址](https:&#x2F;&#x2F;github.com&#x2F;jdavisclark&#x2F;JsFormat)### Part 2 下载配置 C++ 编译环境**安装 TDM-GCC**TDM-GCC 是一款 C++ 编译器，不用 Mingw64 的原因是这个菜鸡到现在还不知道 Mingw 怎么用。。。TDM-GCC的安装包在材料里。[这是官网](https:&#x2F;&#x2F;jmeubank.github.io&#x2F;tdm-gcc&#x2F;)这是 TDM-GCC 的安装界面，打开后点击 Create ，然后无脑式安装就可以了。**一定要把左下打圈圈的钩子给去掉！！！！！！**![Screenshot_7.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;19&#x2F;BLIR3AhQezK1dur.png)**验证和配制环境变量**TDM-GCC 应该会自动帮你配置环境变量。但是也需要检查一下。打开 cmd ，输入 &#96;&#96;&#96;gcc -v&#96;&#96;&#96; 如果没有报错就是成功。应该会出现如下界面。![Screenshot_8.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;19&#x2F;9oINJeLFQKDnlGg.png)但是报错的话，就需要手动配置环境变量。右键桌面上的计算机图标，点击属性，点击高级系统设置 &gt; 高级 &gt; 环境变量 ，在下面的系统变量中找到 Path ，点击编辑，打一个分号之后输入你 TDM-GCC 的安装路径，再在后面打一个 &#96;&#96;&#96;\\bin&#96;&#96;&#96; ，对我来说就是 &#96;&#96;&#96;C:\\TDM-GCC-64\\bin&#96;&#96;&#96;![Screenshot_9.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;26&#x2F;MIY72b5lxPetj68.png)然后再验证一下~~没事找事~~### Part 3 搭建 c++ 环境**新建编译选项**点击 &#96;&#96;&#96;Tools &gt; Build System &gt; New Build Systen &#96;&#96;&#96; ，将里面的内容替换为以下内容 ：&#96;&#96;&#96;javascript&#123; &quot;encoding&quot;: &quot;utf-8&quot;, &quot;working_dir&quot;: &quot;$file_path&quot;, &quot;shell_cmd&quot;: &quot;g++ -Wall -std&#x3D;c++11 \\&quot;$file_name\\&quot; -o \\&quot;$file_base_name\\&quot;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;selector&quot;: &quot;source.c++&quot;, &quot;variants&quot;: [ &#123; &quot;name&quot;: &quot;Sublime Run&quot;, &quot;shell_cmd&quot;: &quot;g++ -Wall -std&#x3D;c++11 \\&quot;$file_name\\&quot; -o \\&quot;$file_base_name\\&quot; &amp;&amp; cmd &#x2F;c \\&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\\&quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;CMD Run&quot;, &quot;shell_cmd&quot;: &quot;g++ -Wall -std&#x3D;c++11 \\&quot;$file\\&quot; -o \\&quot;$file_base_name\\&quot; &amp;&amp; start cmd &#x2F;c \\&quot;\\&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\\&quot; &amp; pause\\&quot;&quot; &#125; ]&#125; 其中 &quot;name&quot;: 后面名字的可以自己更改。 Ctrl + S 不要更改路径保存为 name.sublime-build 其中 name 里的可以自己更改有时候你会觉得自己发明了一个语言 编译运行 Ctrl + Shift + B ,你会发现三个框。 第一个框就是检查一下你有没有编译错误 （相当于 Dev 的编译），第二个框是在 sublime 的内置终端内运行，没什么用因为不能实现输入。一般用的就是第三个 ，像 Dev 一样在 cmd 内运行。 设置快捷键 Ctrl + Shift + B 用不惯 ？可以设置快捷键！ 点击 Preferences &gt; Key Bingdings 在框内输入以下代码 1&#123; &quot;keys&quot;: [&quot;f6&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: &#123;&quot;select&quot;: true&#125; &#125; 这样你的编译运行只要点一下 F6 就会出来框。 录制宏 想要秒出代码？宏录制在这里！ 新建一个空白页，然后 Ctrl + Q ，输入你想录制的宏，然后再次 Ctrl + Q 。如果录制成功的话左下角会显示 recorded macro with xxx commands 。 - Save Macro ``` 不要更改路径保存为 ```name.sublime-macro``` 。 ```name``` 里的自行更改。12345然后点击 &#96;&#96;&#96;Preferences &gt; Key Bingdings &#96;&#96;&#96; ，在右边加入以下代码 ：&#96;&#96;&#96;javascript&#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;:&quot;run_macro_file&quot;, &quot;args&quot;:&#123;&quot;file&quot;:&quot;Packages&#x2F;User&#x2F;name.sublime-macro&quot;&#125; &#125; name 就是你保存的名字。 快捷键可以自己更改，但是 Sublime 的快捷键非常多，所以建议在更改前点击 Find &gt; Find 查找一下有没有冲突，如图所示： 如果右下角显示 Unable to find xxxxx ，就表明可以使用。 Part 4 后记 初次接触 Sublime 应该是搭建 hexo 博客的时候。。。 然后自己搭建编译器和编辑器的时候，几乎是把 OI-Wiki 上的都试遍了，但是还是弄不出来。。。明明就是自己菜 然后就想到了 Sublime ，然后发现确实很好用。。。 然后就没有然后了","tags":[{"name":"工具","slug":"工具","permalink":"https://aksres.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"题解【算法1-6】二分查找与二分答案 题单","date":"2021-02-16T19:14:17.000Z","path":"2021/02/17/题解【算法1-6】二分查找与二分答案 题单/","text":"T1 P2249 【深基13.例1】查找 二分查找的板子 二分查找需要定义三个变量，lll (序列的左端)，rrr (序列的右端)和 midmidmid (中间点)。二分查找的前提是序列有序（一般是升序排列）。 二分查找的原理为：如果中间数小于查找数，那么位置一定在中间数的右边，反之左边。当序列长度为1时停止查找。 以下是程序的板子，最后输出 lll 即可。 123456while(l&lt;r)&#123; mid=(l+r)/2; //防溢出的话也可以写成l+(r-l)/2 if(a[mid]&gt;=x) r=mid; else l=mid+1;&#125; 当然如果你懒得打 mid+1mid+1mid+1 的话，也可以写本人比较喜欢的板子 1234567l&#x3D;1;r&#x3D;n+1; &#x2F;&#x2F;注意这里和下面的的+1while(l+1&lt;r) &#123; mid&#x3D;(l+r)&#x2F;2; if(a[mid]&gt;&#x3D;x) r&#x3D;mid; else l&#x3D;mid;&#125; 然而这个板子的答案有时候会玄学的出现在 l,l−1,l+1l,l-1,l+1l,l−1,l+1 中的一个，所以需要特判。如果这三个答案都不等于查找数，那就是找不到。 该算法单次查询时间复杂度为 O(log⁡n)O(\\log n)O(logn) ，可以通过本题。 AC Code ： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[1000010],x,mid,l,r;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);//因为题目里已经说了有序，就不用再排序了。 for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d&quot;,&amp;x); l=1;r=n+1; while(l+1&lt;r) &#123; mid=(l+r)/2; if(a[mid]&gt;=x) r=mid; else l=mid; &#125; if(a[l]==x) printf(&quot;%d &quot;,l); else if(a[l+1]==x) printf(&quot;%d &quot;,l+1); else printf(&quot;-1 &quot;); &#125; return 0;&#125; T2 P1102 A-B 数对 二分题单？我就不用二分 其实是这个菜鸡不会写二分 对于这道题，我们只需要把等式变成 A=B+CA=B+CA=B+C ，然后用一个 map 记录 aia_iai​ 出现的次数。然后将每个 ai+ca_i+cai​+c 的出现次数累加即可。 因为这题比较简单，所以只要把 map 当普通数组用就行了本来就是这样 当然二分也可以，枚举 bbb ，二分查找满足的 ccc 即可。 AC Code ： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n;long long x,a[2000010],s; //要注意的是longlongmap&lt;long long,long long&gt; b;int main()&#123; cin&gt;&gt;n&gt;&gt;x; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); b[a[i]]++; &#125; for(int i=1;i&lt;=n;i++) s+=b[a[i]+x]; cout&lt;&lt;s; return 0;&#125; T3 P1873 砍树 二分算法分为两种，二分查找和二分答案。 本题就是二分答案的板子。 二分答案的原理是，在一个范围内查找符合题意的最大的答案。（也有可能不是最大）。别的和二分查找基本相同。 和二分查找不同的是，二分答案的范围不是从 111 到 nnn ，同时二分答案多了一个用来检查 midmidmid 是否合法的 check 函数（也可以写在二分 while 循环内） 二分答案的板子 1234567891011121314151617sort(a+1,a+n+1);l=1;r=最大的范围（一般为max&#123;a[i]&#125;+1);while(l+1&lt;r)&#123; mid=(l+r)/2; if(check(mid)) l=mid; else r=mid;&#125;cout&lt;&lt;l; int check(int x)&#123; 定义 for(int i=1;i&lt;=n;i++) do something..... return 合法条件&#125; 对于本题，首先确定查找范围 111 到 $\\max{a_i}+1 $。 LaTeX不会写 然后就是 check 函数，只要求出 ∑i=1Nak−mid\\sum_{i=1}^N a_k-mid∑i=1N​ak​−mid，然后把它和 mmm 比较就行了。 时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn) ，可以通过本题。 AC Code : 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n;long long l,r,mx,a[1000010],m,mid;int check(int x)&#123; long long s=0; for(int i=1;i&lt;=n;i++) if(a[i]&gt;x) s+=(a[i]-x); if(s&gt;=m) return 1; return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123;scanf(&quot;%lld&quot;,&amp;a[i]);mx=max(mx,a[i]);&#125; sort(a+1,a+n+1); l=1;r=mx+1; while(l+1&lt;r) &#123; mid=(l+r)/2; if(check(mid)) l=mid; else r=mid; &#125; cout&lt;&lt;l; return 0;&#125; T4 P1024 [NOIP2001 提高组] 一元三次方程求解 这[数据删除]是二分？ 本题暴力即可。这题掉红的原因就是因为可以暴力。 AC Code ： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;double a,b,c,d;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; for(double i=-100;i&lt;=100;i+=0.001) &#123; double j=i+0.001; double x=a*i*i*i+b*i*i+c*i+d; double y=a*j*j*j+b*j*j+c*j+d; if(x&gt;=0&amp;&amp;y&lt;=0||x&lt;=0&amp;&amp;y&gt;=0) printf(&quot;%.2lf &quot;,i); &#125; return 0;&#125; 诶那你倒是写个二分啊？ 懒的写 T5 P1678 烦恼的高考志愿 因为要相差最小，所以用二分查找到最接近 bib_ibi​且小于其的 ala_lal​,然后取 ∣alk−bi∣,∣al−1−bi∣,∣al+1−bi∣|a_lk-b_i|,|a^{l-1}-b_i|,|a^{l+1}-b_i|∣al​k−bi​∣,∣al−1−bi​∣,∣al+1−bi​∣ 的最小值即可。 同时当 bi&lt;a1b_i&lt;a_1bi​&lt;a1​ 或bi&gt;anb_i&gt;a_nbi​&gt;an​时特判。 AC code ： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;long long a[100100],b[100100],s,l,r,mid;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); sort(a+1,a+n+1); for(int i=1;i&lt;=m;i++) &#123; l=1;r=n+1; while(l+1&lt;r) &#123; mid=(l+r)/2; if(a[mid]&lt;b[i]) l=mid; else r=mid; &#125; if(b[i]&lt;a[1]) s+=abs(a[1]-b[i]); else if(b[i]&gt;a[n]) s+=abs(b[i]-a[n]); else s+=min(min(abs(a[l+1]-b[i]),abs(a[l-1]-b[i])),abs(a[l]-b[i])); &#125; cout&lt;&lt;s; return 0;&#125; T6 P2440 木材加工 二分答案的板子。 对于这道题，需要二分答案的就是题目所求的最大值。如果长度为 midmidmid 那么第 iii 个木条就会被切割成 ⌊aimid⌋\\left\\lfloor\\dfrac{a_i}{mid}\\right\\rfloor⌊midai​​⌋ 断，因此求出∑i=1N⌊aimid⌋\\sum_{i=1}^N \\left\\lfloor\\dfrac{a_i}{mid}\\right\\rfloor∑i=1N​⌊midai​​⌋ 的值，和 mmm 进行比较，就是 check 函数了。 因为最大的一段不肯能超过 max⁡ai\\max{a_i}maxai​ ,所以把 rrr 的初始值定为 max⁡ai+1\\max{a_i}+1maxai​+1。 对于 000 的情况，因为切 111 厘米的小段就是段数最多的情况，所以将读入的 aaa 数组求和，如果和小于 mmm ，则就是切不出来。 AC Code ： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,l,r,mid;long long a[100010],mx,m,sum;int check(int x)&#123; long long s=0; for(int i=1;i&lt;=n;i++) s+=a[i]/x; if(s&gt;=m) return 1; return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123;scanf(&quot;%lld&quot;,&amp;a[i]);mx=max(mx,a[i]);sum+=a[i];&#125; if(sum&lt;m) &#123;cout&lt;&lt;0;return 0;&#125; l=1;r=mx+1; while(l+1&lt;r) &#123; mid=(l+r)/2; if(check(mid)) l=mid; else r=mid; &#125; cout&lt;&lt;l; return 0;&#125; T7 P2678 [NOIP2015 提高组] 跳石头 不错，长得真像二分。 本来就是二分 Part 1 预处理 弄得这么高大上干嘛 题目给你的只是中间的距离，还需要处理起点和终点，所以 a0=1a_0=1a0​=1 ， an+1=la_{n+1}=lan+1​=l 然后确定搜索范围，本题需要二分答案的依然是题目所求的，所以 left=1left=1left=1 ，right=l+1right=l+1right=l+1 。 Part 2 check 函数 ttt 表示共移走的石头， kkk 表示不需要移走的石头的下标。 那么，当 aia_iai​ 和 aka_kak​ 的距离小于待验证距离 midmidmid 时，就需要移走一块石头，因为题目要求的是最大值，所以两块距离大于等于 midmidmid 的石头之间不应该再有多余的石头。 AC code : 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define inf 2147483647using namespace std;int n,m;long long l,r,mid,d,a[123333];int check(long long x)&#123; long long k=0,t=0; for(int i=1;i&lt;=n+1;i++) if(a[i]-a[k]&lt;x) t++; else k=i; return t&lt;=m;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); a[n+1]=d; sort(a+1,a+n+2); l=0;r=d+1; while(l+1&lt;r) &#123; mid=(l+r)/2; if(check(mid)) l=mid; else r=mid; &#125; cout&lt;&lt;l; return 0;&#125; T8 P3853 [TJOI2007]路标设置 没什么可说的了你还想说什么，直接写 check 函数。 设待验证的空旷指数为 xxx ，那么当有 ai−ai−1&gt;xa_i-a_{i-1} &gt; xai​−ai−1​&gt;x 时，就需要添加路牌。 需要注意的是，当 ai−ai−1a_i-a_{i-1}ai​−ai−1​ 能被 xxx 整除时，其中一端的路牌就不用加了。 用代码写出来是这样的 123//ans表示一共添加的路牌数量if((a[i]-a[i-1])%x==0) ans+=(a[i]-a[i-1])/x-1; else ans+=(a[i]-a[i-1])/x; 最后把 ansansans 和 kkk 比较即可。 还有一个坑点，这题的答案是求最小值，而前面的题目是最大值，所以需要把二分判断中的 if(check(mid)) 改成 if(!check(mid)) 。 AC Code ： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int p,n,m,l,r,mid,a[233333];int check(int x)&#123; int ans=0; for(int i=2;i&lt;=n;i++) if(a[i]-a[i-1]&gt;=x) &#123; if((a[i]-a[i-1])%x==0) ans+=(a[i]-a[i-1])/x-1; else ans+=(a[i]-a[i-1])/x; &#125; return ans&lt;=m;&#125;int main()&#123; cin&gt;&gt;p&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); l=1;r=p+1; while(l+1&lt;r) &#123; mid=(l+r)/2; if(!check(mid)) l=mid; else r=mid; &#125; cout&lt;&lt;l+1; return 0;&#125; T9 P1182 数列分段 Section II 菜到先用爆搜写了 1h ，再用区间 dp 写了 1h 。。。。 最后发现这题二分的依然是答案 （（（（（ 主程序依旧是板子，二分题目的颜色估计就是 check 函数决定吧。。。 唯一注意的就是 lll 需要定义成 aia_iai​ 中的最大值，rrr 需要定义成所有 aia_iai​ 的和。分别表示切 n−1n-1n−1 段和切 111 。 定义 sss 表示每段之和, ttt 表示分的段数，待验证的答案为 xxx。则当 $s+a_i &gt; x $ 时，就需要重新分一段，同时将 i−1i-1i−1 作为新一段的起点。 最后将 ttt 和 mmm 比较即可。 AC code ： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,l,r,mid,sum,a[233333];int check(int x)&#123; int s=0,t=0; for(int i=1;i&lt;=n;i++) if(s+a[i]&lt;=x) s+=a[i]; else &#123;s=a[i];t++;&#125; return t&gt;=m;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); r+=a[i]; l=max(l,a[i]); &#125; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; cout&lt;&lt;l; return 0;&#125; 最后说一下吧，这种类似于贪心的策略是错误的，题目中给出的例子很明显的 hack 了这个代码，它似乎只会把 444 和 222 放一段，而不会把 444 单独放。本来这个代码只有 202020 分，但是将我自己的板子换成传统的二分板子之后就 AC 了，可能是数据的问题。 在第一篇题解下面的评论区中确实有人提出过，但是没有被重视。所以我希望大佬们可以解答一下我的疑惑。 这题正确的方法应该是前缀和二分，但我自己的板子再次被卡掉了，如果 l+1l+1l+1 输出就有 808080 但是第四个点恰好不需要加一。 这就是这道题比较麻烦的地方。 T10 P1163 银行贷款 这 是 二 分 ? 我记得当时调了三个小时没 A 气得直接把讨论区求助代码调对了结果自己还是没 A Part 1 确定搜索范围 反正二分的基本就是答案，所以就直接套班子。 利率的左端 lll 就是 000 ，而右端就需要一些动画知识。根据阿凡达我们知道高利贷的利率不会超过 101010 抢钱所以把 rrr 定义为 10.010.010.0 。 因为误差不需要超过 0.1%0.1\\%0.1% ，把 while 里的条件写为 r−l&gt;0.0001r-l&gt;0.0001r−l&gt;0.0001 （精度） 注意的是 lll ， rrr ， midmidmid ，全部要定义为 double 。 ps ：最后输出的时候一定要乘 100100100 ,题目求的是百分数. Part 2 check 函数 比较方便的就是计算在这个利率下是否能刚好还玩 （多还亿一点点也可以） 设 ttt 为剩余的钱， xxx 为待验证的利率，计算利率的时候简便的方法就是把 ttt 每次增大 xxx 倍，再减去每个月还的钱。 AC code : 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;double p,l,r,mid;int n,m;int check(double x)&#123; double t=p; //刚开始剩余的钱数就是贷款原值 for(int i=1;i&lt;=m;i++) t=(1.0+x)*1.0*t-1.0*n; return t&lt;=0;&#125;int main()&#123; cin&gt;&gt;p&gt;&gt;n&gt;&gt;m; l=0.0;r=10.0; while(r-l&gt;0.0001) &#123; mid=(l+r)/2.0; if(check(mid)) l=mid; else r=mid; &#125; printf(&quot;%.1lf&quot;,1.0*l*100.0); //百分数！ return 0;&#125; T11 P3743 kotori的设备 蓝题？玩你m Part 1 无限使用 很简单，只要所有设备一秒内消耗的能量小于等于充电宝一秒内能提供的能量，就意味着能够一直充电。 Part 2 主程序 既然所有和的最大值是 101010^{10}1010 那么就把右边界定义为 101010^{10}1010 。 然后，题目要求的精度是 10−410^{-4}10−4 ，所以当 rrr 和 lll 相差小于等于 10−410^{-4}10−4 时结束 while 循环。 这样看似范围很大，但是二分的时间复杂度是 O(log⁡n）O (\\log n）O(logn） ，即使是大数据也就几十而已。 Part 3 check 函数 设待验证的时间为 xxx 则充电宝最多可以提供 x∗px*px∗p 的能量。设 ttt 表示在时间 xxx 内所需充电宝能量，则如果一个设备在 xxx 秒内消耗的能量小于原来储存的能量，就不需要使用充电宝。 反之，如果要使用充电宝，那么充电宝消耗的能量就是这个设备在 xxx 秒内消耗的能量减去原储存能量。用 ttt 做一个累加即可。 最后如果 ttt 小于等于 ppp ，就意味着这个时间是合法的。 AC code ： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;struct aksres&#123; double x,y;&#125;a[233333];int n;double p,sum,l,r,mid;int check(double x)&#123; double s=x*p,t=0; for(int i=1;i&lt;=n;i++) t+=max(0,x*a[i].x-a[i].y); return t&lt;=s;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;p; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y); sum+=a[i].x; &#125; if(sum&lt;=p) &#123;cout&lt;&lt;&quot;-1&quot;;return 0;&#125; l=0.0;r=1e10; while(r-l&gt;0.0001) &#123; mid=(l+r)/2.0; if(check(mid)) l=mid; else r=mid; &#125; printf(&quot;%.6lf&quot;,l); return 0;&#125;","tags":[{"name":"题解","slug":"题解","permalink":"https://aksres.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"乱七八糟的公告","date":"2020-09-20T15:44:31.000Z","path":"2020/09/20/乱七八糟的公告/","text":"热烈祝贺菜 Aksres 的网站在 8.27 搭建完毕 ！ Part 1 关于 本站点是一个基于 Github+Hexo 的 blog 型网站，使用主题为 stun 没了，就这么多 Part 2 站内规则 只要你不把这个网站黑掉干啥都行 Part 3 一些注意事项 某些一堆页面会404，正在修（咕咕咕 ipad 或者手机的某些地方会出现渲染问题，见谅。 好像根本打不开 不知道为什么显示文章的地方可能会由于一些 hexo 的玄学原因出现卡顿情况，见谅。 分享功能坏了 打赏怎么关掉啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 Part 4 鸣谢 感谢千古神犇Venus的极其详细的日报讲解 感谢zhanghengrui神仙，WEMS_PZC神仙，tim1103神仙提供的 Git ，Sublime下载地址。 感谢我自己垃圾至极的搭建给大家带来了亿点点麻烦 完 结 撒 花","tags":[{"name":"公告","slug":"公告","permalink":"https://aksres.github.io/tags/%E5%85%AC%E5%91%8A/"}]}]